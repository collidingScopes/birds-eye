<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Character in Cesium City - Follow Camera with Jumping and City Selection</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        html, body {
            width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: sans-serif;
            background: #000;
        }
        #cesiumContainer {
            width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 0;
        }
        #threeContainer {
            width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1;
            pointer-events: none;
        }
        #threeCanvas {
            width: 100%; height: 100%; display: block;
        }
        #instructions {
            position: absolute; bottom: 10px; left: 10px;
            background: rgba(40, 40, 40, 0.8); color: white;
            padding: 10px 15px; border-radius: 5px; font-size: 12px;
            z-index: 10; pointer-events: none;
        }
        #citySelector {
            position: absolute; top: 10px; left: 10px;
            background: rgba(40, 40, 40, 0.8); color: white;
            padding: 5px; border-radius: 5px; font-size: 14px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="cesiumContainer"></div>
    <div id="threeContainer">
        <canvas id="threeCanvas"></canvas>
    </div>
    <select id="citySelector">
        <option value="nyc">New York City</option>
        <option value="london">London</option>
        <option value="tokyo">Tokyo</option>
        <option value="paris">Paris</option>
        <option value="sydney">Sydney</option>
        <option value="montreal">Montreal</option>
        <option value="toronto">Toronto</option>
        <option value="istanbul">Istanbul</option>
        <option value="hanoi">Hanoi</option>
        <option value="hongkong">Hong Kong</option>
    </select>
    <div id="instructions">
        W/S: Move Forward/Backward<br>
        A/D: Turn Player<br>
        Up/Down Arrows: Look Up/Down<br>
        Space: Jump<br>
        Loading City Data...
    </div>

    <script>
        Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIxY2FhMzA2MS1jOWViLTRiYWUtODJmZi02YjAxMmM5MGI3MzkiLCJpZCI6MjkxMTc3LCJpYXQiOjE3NDM4ODA1Mjd9.Js54F7Sh9x04MT9-MjRAL5qm97R_pw7xSrAIS9I8wY4';

        const playerMoveSpeed = 60.0;
        const turnSpeed = 4.0;
        const cameraFollowSpeed = 5.0;
        const cameraDistance = 5.0;
        const jumpVelocity = 100;
        const gravity = -50.0;
        const groundHeight = 20.0;

        // City coordinates (longitude, latitude)
        const cities = {
            nyc: { longitude: -73.9854, latitude: 40.7580 },
            london: { longitude: -0.1276, latitude: 51.5074 },
            tokyo: { longitude: 139.6917, latitude: 35.6895 },
            paris: { longitude: 2.3522, latitude: 48.8566 },
            sydney: { longitude: 151.2093, latitude: -33.8688 },
            montreal: { longitude: -73.5674, latitude: 45.5019 },
            toronto: { longitude: -79.3832, latitude: 43.6532 },
            istanbul: { longitude: 28.9784, latitude: 41.0082 },
            hanoi: { longitude: 105.8342, latitude: 21.0278 },
            hongkong: { longitude: 114.1694, latitude: 22.3193 }
        };

        let playerPosition = Cesium.Cartographic.fromDegrees(cities.nyc.longitude, cities.nyc.latitude, groundHeight);
        let playerHeading = Cesium.Math.toRadians(0.0);
        let cameraHeading = Cesium.Math.toRadians(0.0);
        let cameraPitch = Cesium.Math.toRadians(-15.0);
        let verticalVelocity = 0.0;

        const inputState = {
            forward: false, backward: false, turnLeft: false, turnRight: false,
            lookUp: false, lookDown: false, jump: false
        };

        const instructionsElement = document.getElementById('instructions');
        const citySelector = document.getElementById('citySelector');

        // Cesium Setup
        const viewer = new Cesium.Viewer('cesiumContainer', {
            animation: false, baseLayerPicker: false, fullscreenButton: false, geocoder: false,
            homeButton: false, infoBox: false, sceneModePicker: false, selectionIndicator: false,
            timeline: false, navigationHelpButton: false, scene3DOnly: true,
            useDefaultRenderLoop: false,
            maximumScreenSpaceError: 4
        });

        viewer.scene.screenSpaceCameraController.enableInputs = false;
        const cesiumCamera = viewer.camera;

        // Load OSM Buildings
        let osmBuildingsTileset = null;
        async function loadOsmBuildings() {
            try {
                osmBuildingsTileset = await Cesium.Cesium3DTileset.fromIonAssetId(96188);
                viewer.scene.primitives.add(osmBuildingsTileset);
                osmBuildingsTileset.style = new Cesium.Cesium3DTileStyle({ color: "color('#e0e0e0')" });
                instructionsElement.innerHTML = "W/S: Move Forward/Backward<br>A/D: Turn Player<br>Up/Down Arrows: Look Up/Down<br>Space: Jump<br>Facing: East";
            } catch (error) {
                console.error(`Error loading Cesium OSM Buildings: ${error}`);
                instructionsElement.innerHTML = "Error loading city data.<br>Check console.";
                instructionsElement.style.color = 'red';
            }
        }

        // Three.js Setup
        const three = { scene: null, camera: null, renderer: null, playerMesh: null };
        function initThree() {
            const scene = new THREE.Scene();
            const canvas = document.getElementById('threeCanvas');
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            three.camera = camera;
            const renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.autoClear = false;
            three.renderer = renderer;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 10, 5);
            scene.add(directionalLight);

            const radius = 0.3;
            const height = 1.0;
            const cylinder = new THREE.CylinderGeometry(radius, radius, height, 8);
            const material = new THREE.MeshStandardMaterial({ color: 0xff8800 });
            const playerMesh = new THREE.Mesh(cylinder, material);
            playerMesh.position.set(0, height / 2, 0);
            scene.add(playerMesh);
            scene.add(camera);
            three.scene = scene;
            three.playerMesh = playerMesh;
        }

        // Input Handling
        function setupInputListeners() {
            document.addEventListener('keydown', (event) => {
                const key = event.key.toUpperCase();
                switch (key) {
                    case 'W': inputState.forward = true; break;
                    case 'S': inputState.backward = true; break;
                    case 'A': inputState.turnLeft = true; break;
                    case 'D': inputState.turnRight = true; break;
                    case 'ARROWUP': inputState.lookUp = true; break;
                    case 'ARROWDOWN': inputState.lookDown = true; break;
                    case ' ': inputState.jump = true; break;
                }
            });
            document.addEventListener('keyup', (event) => {
                const key = event.key.toUpperCase();
                switch (key) {
                    case 'W': inputState.forward = false; break;
                    case 'S': inputState.backward = false; break;
                    case 'A': inputState.turnLeft = false; break;
                    case 'D': inputState.turnRight = false; break;
                    case 'ARROWUP': inputState.lookUp = false; break;
                    case 'ARROWDOWN': inputState.lookDown = false; break;
                    case ' ': inputState.jump = false; break;
                }
            });

            // City selection handler
            citySelector.addEventListener('change', (event) => {
                const selectedCity = event.target.value;
                const cityCoords = cities[selectedCity];
                playerPosition = Cesium.Cartographic.fromDegrees(cityCoords.longitude, cityCoords.latitude, groundHeight);
                verticalVelocity = 0; // Reset velocity to prevent falling after teleport
                playerHeading = Cesium.Math.toRadians(0.0); // Reset heading
                cameraHeading = Cesium.Math.toRadians(0.0); // Sync camera heading
            });
        }

        // Direction Helper
        function getDirection(heading) {
            let degrees = Cesium.Math.toDegrees(heading) % 360;
            if (degrees < 0) degrees += 360;
            if (degrees >= 337.5 || degrees < 22.5) return "North";
            if (degrees >= 22.5 && degrees < 67.5) return "Northeast";
            if (degrees >= 67.5 && degrees < 112.5) return "East";
            if (degrees >= 112.5 && degrees < 157.5) return "Southeast";
            if (degrees >= 157.5 && degrees < 202.5) return "South";
            if (degrees >= 202.5 && degrees < 247.5) return "Southwest";
            if (degrees >= 247.5 && degrees < 292.5) return "West";
            if (degrees >= 292.5 && degrees < 337.5) return "Northwest";
            return "Unknown";
        }

        // Update Loop
        let lastTime = 0;
        function update(currentTime) {
            const deltaTime = (currentTime - (lastTime || currentTime)) / 1000.0;
            lastTime = currentTime;

            // 1. Update Player Heading (A/D keys)
            if (inputState.turnLeft) playerHeading -= turnSpeed * deltaTime;
            if (inputState.turnRight) playerHeading += turnSpeed * deltaTime;
            playerHeading = Cesium.Math.zeroToTwoPi(playerHeading);

            // 2. Smoothly interpolate camera heading to match player heading
            const headingDiff = Cesium.Math.zeroToTwoPi(playerHeading - cameraHeading);
            const shortestDiff = headingDiff > Math.PI ? headingDiff - Cesium.Math.TWO_PI : headingDiff;
            cameraHeading += shortestDiff * cameraFollowSpeed * deltaTime;
            cameraHeading = Cesium.Math.zeroToTwoPi(cameraHeading);

            // 3. Update Camera Pitch (Up/Down arrows)
            if (inputState.lookUp) cameraPitch += turnSpeed * deltaTime;
            if (inputState.lookDown) cameraPitch -= turnSpeed * deltaTime;
            cameraPitch = Cesium.Math.clamp(cameraPitch, -Cesium.Math.PI_OVER_TWO + 0.05, Cesium.Math.toRadians(20));

            // 4. Handle Jumping and Gravity
            if (inputState.jump) {
                verticalVelocity = jumpVelocity;
                inputState.jump = false;
            }
            verticalVelocity += gravity * deltaTime;
            playerPosition.height += verticalVelocity * deltaTime;
            if (playerPosition.height < groundHeight) {
                playerPosition.height = groundHeight;
                verticalVelocity = 0;
            }

            // 5. Update Player Position (W/S) based on cameraHeading
            const moveAmount = playerMoveSpeed * deltaTime;
            let moveDirection = new Cesium.Cartesian3(0, 0, 0);
            const playerWorldPos = Cesium.Cartesian3.fromRadians(playerPosition.longitude, playerPosition.latitude, playerPosition.height);
            const enuTransform = Cesium.Transforms.eastNorthUpToFixedFrame(playerWorldPos);

            if (inputState.forward || inputState.backward) {
                const direction = inputState.forward ? 1 : -1;
                moveDirection.x = direction * Math.cos(cameraHeading);
                moveDirection.y = direction * Math.sin(cameraHeading);
                Cesium.Cartesian3.normalize(moveDirection, moveDirection);
                Cesium.Cartesian3.multiplyByScalar(moveDirection, moveAmount, moveDirection);

                const moveECEF = Cesium.Matrix4.multiplyByPointAsVector(enuTransform, moveDirection, new Cesium.Cartesian3());
                const newWorldPos = Cesium.Cartesian3.add(playerWorldPos, moveECEF, new Cesium.Cartesian3());
                const newCartographic = Cesium.Cartographic.fromCartesian(newWorldPos);
                playerPosition.longitude = newCartographic.longitude;
                playerPosition.latitude = newCartographic.latitude;
            }

            // 6. Position Camera Behind Player
            const targetWorldPosition = Cesium.Cartesian3.fromRadians(playerPosition.longitude, playerPosition.latitude, playerPosition.height);
            cesiumCamera.setView({
                destination: targetWorldPosition,
                orientation: { heading: cameraHeading, pitch: cameraPitch, roll: 0.0 }
            });
            cesiumCamera.moveBackward(cameraDistance);

            // 7. Update Player Mesh Orientation
            three.playerMesh.rotation.y = -playerHeading;

            // 8. Sync Three.js Camera
            three.renderer.clear();
            three.camera.projectionMatrix.fromArray(cesiumCamera.frustum.projectionMatrix);
            three.camera.matrixWorldInverse.fromArray(cesiumCamera.viewMatrix);
            three.camera.matrixWorld.copy(three.camera.matrixWorldInverse).invert();

            // 9. Render
            viewer.render();
            three.renderer.render(three.scene, three.camera);

            // 10. Update Instructions
            instructionsElement.innerHTML = `W/S: Move Forward/Backward<br>A/D: Turn Player<br>Up/Down Arrows: Look Up/Down<br>Space: Jump<br>Facing: ${getDirection(playerHeading)}`;

            requestAnimationFrame(update);
        }

        // Initialization
        initThree();
        setupInputListeners();
        loadOsmBuildings();

        const initialTargetWorldPos = Cesium.Cartesian3.fromRadians(playerPosition.longitude, playerPosition.latitude, playerPosition.height);
        cesiumCamera.setView({
            destination: initialTargetWorldPos,
            orientation: { heading: cameraHeading, pitch: cameraPitch, roll: 0.0 }
        });
        cesiumCamera.moveBackward(cameraDistance);

        requestAnimationFrame(update);

        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            three.renderer.setSize(width, height);
            three.camera.aspect = width / height;
            three.camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>