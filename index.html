<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Character in Cesium City - Follow Camera with Jumping and City Selection</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        html, body {
            width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: sans-serif;
            background: #000;
        }
        #cesiumContainer {
            width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 0;
        }
        #threeContainer {
            width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1;
            pointer-events: none;
        }
        #threeCanvas {
            width: 100%; height: 100%; display: block;
        }
        #instructions {
            position: absolute; bottom: 10px; left: 10px;
            background: rgba(40, 40, 40, 0.8); color: white;
            padding: 10px 15px; border-radius: 5px; font-size: 12px;
            z-index: 10; pointer-events: none;
        }
        #citySelector {
            position: absolute; top: 10px; left: 10px;
            background: rgba(40, 40, 40, 0.8); color: white;
            padding: 5px; border-radius: 5px; font-size: 14px;
            z-index: 10;
        }
        #fpsCounter {
            position: absolute; bottom: 10px; right: 10px;
            background: rgba(40, 40, 40, 0.8); color: white;
            padding: 5px 10px; border-radius: 5px; font-size: 14px;
            z-index: 10; pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="cesiumContainer"></div>
    <div id="threeContainer">
        <canvas id="threeCanvas"></canvas>
    </div>
    <select id="citySelector">
        <option value="nyc">New York City</option>
        <option value="london">London</option>
        <option value="tokyo">Tokyo</option>
        <option value="paris">Paris</option>
        <option value="sydney">Sydney</option>
        <option value="montreal">Montreal</option>
        <option value="toronto">Toronto</option>
        <option value="istanbul">Istanbul</option>
        <option value="hanoi">Hanoi</option>
        <option value="hongkong">Hong Kong</option>
    </select>
    <div id="instructions">
        W/S: Move Forward/Backward<br>
        A/D: Strafe Left/Right<br>
        Arrow Keys: Move Camera<br>
        Space: Jump<br>
        Loading City Data...
    </div>
    <div id="fpsCounter">FPS: 0</div>

    <script>
        Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIxY2FhMzA2MS1jOWViLTRiYWUtODJmZi02YjAxMmM5MGI3MzkiLCJpZCI6MjkxMTc3LCJpYXQiOjE3NDM4ODA1Mjd9.Js54F7Sh9x04MT9-MjRAL5qm97R_pw7xSrAIS9I8wY4';

        const playerMoveSpeed = 100.0;
        const cameraTurnSpeed = 2.0;
        const cameraFollowSpeed = 3.0;
        const cameraDistance = 20.0;
        const jumpVelocity = 100;
        const gravity = -50.0;
        const groundHeight = 30.0;

        const cities = {
            nyc: { longitude: -73.9854, latitude: 40.7580 },
            london: { longitude: -0.1276, latitude: 51.5074 },
            tokyo: { longitude: 139.6917, latitude: 35.6895 },
            paris: { longitude: 2.3522, latitude: 48.8566 },
            sydney: { longitude: 151.2093, latitude: -33.8688 },
            montreal: { longitude: -73.5674, latitude: 45.5019 },
            toronto: { longitude: -79.3832, latitude: 43.6532 },
            istanbul: { longitude: 28.9784, latitude: 41.0082 },
            hanoi: { longitude: 105.8342, latitude: 21.0278 },
            hongkong: { longitude: 114.1694, latitude: 22.3193 }
        };

        let playerPosition = Cesium.Cartographic.fromDegrees(cities.nyc.longitude, cities.nyc.latitude, groundHeight);
        let playerHeading = Cesium.Math.toRadians(0.0);
        let cameraHeading = Cesium.Math.toRadians(0.0);
        let cameraPitch = Cesium.Math.toRadians(-15.0);
        let verticalVelocity = 0.0;
        let forwardDirection = { x: 1, y: 0 };
        let rightDirection = { x: 0, y: -1 };

        const inputState = {
            forward: false, 
            backward: false, 
            left: false, 
            right: false,
            up: false, 
            down: false, 
            jump: false,
            strafeLeft: false,
            strafeRight: false
        };

        const instructionsElement = document.getElementById('instructions');
        const citySelector = document.getElementById('citySelector');
        const fpsCounter = document.getElementById('fpsCounter');

        // FPS tracking variables
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let currentFps = 0;

        const viewer = new Cesium.Viewer('cesiumContainer', {
            animation: false, baseLayerPicker: false, fullscreenButton: false, geocoder: false,
            homeButton: false, infoBox: false, sceneModePicker: false, selectionIndicator: false,
            timeline: false, navigationHelpButton: false, scene3DOnly: true,
            useDefaultRenderLoop: false,
            maximumScreenSpaceError: 4
        });

        viewer.scene.screenSpaceCameraController.enableInputs = false;
        const cesiumCamera = viewer.camera;

        let osmBuildingsTileset = null;
        async function loadOsmBuildings() {
            try {
                osmBuildingsTileset = await Cesium.Cesium3DTileset.fromIonAssetId(96188);
                viewer.scene.primitives.add(osmBuildingsTileset);
                osmBuildingsTileset.style = new Cesium.Cesium3DTileStyle({ color: "color('#e0e0e0')" });
                instructionsElement.innerHTML = "W/S: Move Forward/Backward<br>A/D: Strafe Left/Right<br>Arrow Keys: Move Camera<br>Space: Jump<br>Facing: East";
            } catch (error) {
                console.error(`Error loading Cesium OSM Buildings: ${error}`);
                instructionsElement.innerHTML = "Error loading city data.<br>Check console.";
                instructionsElement.style.color = 'red';
            }
        }

        const three = { scene: null, camera: null, renderer: null, playerMesh: null };
        function initThree() {
            const scene = new THREE.Scene();
            const canvas = document.getElementById('threeCanvas');
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            three.camera = camera;
            const renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.autoClear = false;
            three.renderer = renderer;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 10, 5);
            scene.add(directionalLight);

            const radius = 0.3;
            const height = 1.0;
            const cylinder = new THREE.CylinderGeometry(radius, radius, height, 8);
            const material = new THREE.MeshStandardMaterial({ color: 0xff8800 });
            const playerMesh = new THREE.Mesh(cylinder, material);
            playerMesh.position.set(0, height / 2, 0);
            scene.add(playerMesh);
            scene.add(camera);
            three.scene = scene;
            three.playerMesh = playerMesh;
        }

        function updateDirectionVectors() {
            // Cesium uses East-North-Up coordinate system
            // East is 0 degrees, North is 90 degrees
            // Forward direction vector
            forwardDirection.x = Math.sin(playerHeading);  // East component
            forwardDirection.y = Math.cos(playerHeading);  // North component
            
            // Right direction vector (perpendicular to forward direction)
            rightDirection.x = Math.sin(playerHeading + Math.PI/2);  // East component
            rightDirection.y = Math.cos(playerHeading + Math.PI/2);  // North component
        }

        function setupInputListeners() {
            document.addEventListener('keydown', (event) => {
                const key = event.key.toUpperCase();
                switch (key) {
                    case 'W': inputState.forward = true; break;
                    case 'S': inputState.backward = true; break;
                    case 'A': inputState.strafeLeft = true; break;
                    case 'D': inputState.strafeRight = true; break;
                    case 'ARROWLEFT': inputState.left = true; break;
                    case 'ARROWRIGHT': inputState.right = true; break;
                    case 'ARROWUP': inputState.up = true; break;
                    case 'ARROWDOWN': inputState.down = true; break;
                    case ' ': inputState.jump = true; break;
                }
            });
            document.addEventListener('keyup', (event) => {
                const key = event.key.toUpperCase();
                switch (key) {
                    case 'W': inputState.forward = false; break;
                    case 'S': inputState.backward = false; break;
                    case 'A': inputState.strafeLeft = false; break;
                    case 'D': inputState.strafeRight = false; break;
                    case 'ARROWLEFT': inputState.left = false; break;
                    case 'ARROWRIGHT': inputState.right = false; break;
                    case 'ARROWUP': inputState.up = false; break;
                    case 'ARROWDOWN': inputState.down = false; break;
                    case ' ': inputState.jump = false; break;
                }
            });

            citySelector.addEventListener('change', (event) => {
                const selectedCity = event.target.value;
                const cityCoords = cities[selectedCity];
                playerPosition = Cesium.Cartographic.fromDegrees(cityCoords.longitude, cityCoords.latitude, groundHeight);
                verticalVelocity = 0;
                playerHeading = Cesium.Math.toRadians(0.0);
                cameraHeading = Cesium.Math.toRadians(0.0);
                updateDirectionVectors();
            });
        }

        function getDirection(heading) {
            let degrees = Cesium.Math.toDegrees(heading) % 360;
            if (degrees < 0) degrees += 360;
            if (degrees >= 337.5 || degrees < 22.5) return "North";
            if (degrees >= 22.5 && degrees < 67.5) return "Northeast";
            if (degrees >= 67.5 && degrees < 112.5) return "East";
            if (degrees >= 112.5 && degrees < 157.5) return "Southeast";
            if (degrees >= 157.5 && degrees < 202.5) return "South";
            if (degrees >= 202.5 && degrees < 247.5) return "Southwest";
            if (degrees >= 247.5 && degrees < 292.5) return "West";
            if (degrees >= 292.5 && degrees < 337.5) return "Northwest";
            return "Unknown";
        }

        let lastTime = 0;
        function update(currentTime) {
            const deltaTime = (currentTime - (lastTime || currentTime)) / 1000.0;
            lastTime = currentTime;

            // Update FPS counter
            frameCount++;
            if (currentTime - lastFpsUpdate >= 1000) {
                currentFps = Math.round(frameCount * 1000 / (currentTime - lastFpsUpdate));
                fpsCounter.textContent = `FPS: ${currentFps}`;
                frameCount = 0;
                lastFpsUpdate = currentTime;
            }

            // 1. Update Camera Heading (Left/Right arrows)
            if (inputState.left) {
                cameraHeading -= cameraTurnSpeed * deltaTime;
                playerHeading -= cameraTurnSpeed * deltaTime;
                updateDirectionVectors();
            }
            if (inputState.right) {
                cameraHeading += cameraTurnSpeed * deltaTime;
                playerHeading += cameraTurnSpeed * deltaTime;
                updateDirectionVectors();
            }
            cameraHeading = Cesium.Math.zeroToTwoPi(cameraHeading);
            playerHeading = Cesium.Math.zeroToTwoPi(playerHeading);

            // 2. Update Camera Pitch (Up/Down arrows)
            if (inputState.up) cameraPitch += cameraTurnSpeed * deltaTime;
            if (inputState.down) cameraPitch -= cameraTurnSpeed * deltaTime;
            cameraPitch = Cesium.Math.clamp(cameraPitch, -Cesium.Math.PI_OVER_TWO + 0.05, Cesium.Math.toRadians(groundHeight));

            // 3. Handle Jumping and Gravity
            if (inputState.jump) {
                verticalVelocity = jumpVelocity;
                inputState.jump = false;
            }
            verticalVelocity += gravity * deltaTime;
            playerPosition.height += verticalVelocity * deltaTime;
            if (playerPosition.height < groundHeight) {
                playerPosition.height = groundHeight;
                verticalVelocity = 0;
            }

            // 4. Update Player Position (W/S/A/D) using direction vectors
            const moveAmount = playerMoveSpeed * deltaTime;
            let moveDirection = new Cesium.Cartesian3(0, 0, 0);
            const playerWorldPos = Cesium.Cartesian3.fromRadians(playerPosition.longitude, playerPosition.latitude, playerPosition.height);
            const enuTransform = Cesium.Transforms.eastNorthUpToFixedFrame(playerWorldPos);

            // Handle forward/backward movement
            if (inputState.forward || inputState.backward) {
                const direction = inputState.forward ? 1 : -1;
                moveDirection.x += forwardDirection.x * direction;
                moveDirection.y += forwardDirection.y * direction;
            }
            
            // Handle strafing (left/right sideways movement)
            if (inputState.strafeLeft || inputState.strafeRight) {
                const direction = inputState.strafeLeft ? -1 : 1;
                moveDirection.x += rightDirection.x * direction;
                moveDirection.y += rightDirection.y * direction;
            }
            
            // Apply movement if any direction keys are pressed
            if (inputState.forward || inputState.backward || inputState.strafeLeft || inputState.strafeRight) {
                Cesium.Cartesian3.normalize(moveDirection, moveDirection);
                Cesium.Cartesian3.multiplyByScalar(moveDirection, moveAmount, moveDirection);

                const moveECEF = Cesium.Matrix4.multiplyByPointAsVector(enuTransform, moveDirection, new Cesium.Cartesian3());
                const newWorldPos = Cesium.Cartesian3.add(playerWorldPos, moveECEF, new Cesium.Cartesian3());
                const newCartographic = Cesium.Cartographic.fromCartesian(newWorldPos);
                playerPosition.longitude = newCartographic.longitude;
                playerPosition.latitude = newCartographic.latitude;
            }

            // 5. Position Camera Behind Player
            const targetWorldPosition = Cesium.Cartesian3.fromRadians(playerPosition.longitude, playerPosition.latitude, playerPosition.height);
            cesiumCamera.setView({
                destination: targetWorldPosition,
                orientation: { heading: cameraHeading, pitch: cameraPitch, roll: 0.0 }
            });
            cesiumCamera.moveBackward(cameraDistance);

            // 6. Update Player Mesh Orientation
            three.playerMesh.rotation.y = -playerHeading;

            // 7. Sync Three.js Camera
            three.renderer.clear();
            three.camera.projectionMatrix.fromArray(cesiumCamera.frustum.projectionMatrix);
            three.camera.matrixWorldInverse.fromArray(cesiumCamera.viewMatrix);
            three.camera.matrixWorld.copy(three.camera.matrixWorldInverse).invert();

            // 8. Render
            viewer.render();
            three.renderer.render(three.scene, three.camera);

            // 9. Update Instructions
            instructionsElement.innerHTML = `W/S: Move Forward/Backward<br>A/D: Strafe Left/Right<br>Arrow Keys: Move Camera<br>Space: Jump<br>Facing: ${getDirection(playerHeading)}`;

            requestAnimationFrame(update);
        }

        initThree();
        setupInputListeners();
        loadOsmBuildings();
        updateDirectionVectors();

        const initialTargetWorldPos = Cesium.Cartesian3.fromRadians(playerPosition.longitude, playerPosition.latitude, playerPosition.height);
        cesiumCamera.setView({
            destination: initialTargetWorldPos,
            orientation: { heading: cameraHeading, pitch: cameraPitch, roll: 0.0 }
        });
        cesiumCamera.moveBackward(cameraDistance);

        requestAnimationFrame(update);

        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            three.renderer.setSize(width, height);
            three.camera.aspect = width / height;
            three.camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>